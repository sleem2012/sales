



abstract class AppsNames with _$AppsNames{
  const factory AppsNames.sales() = AppsNamesSales;
  const factory AppsNames.vendor() = AppsNamesVendor;
  const factory AppsNames.client() = AppsNamesClient;
  const factory AppsNames.delivery() = AppsNamesDelivery;
}





// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark


T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$AppsNames {
  TResult when<TResult extends Object?>({
    required TResult Function() sales,
    required TResult Function() vendor,
    required TResult Function() client,
    required TResult Function() delivery,
  }) =>
      throw _privateConstructorUsedError;

  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? sales,
    TResult? Function()? vendor,
    TResult? Function()? client,
    TResult? Function()? delivery,
  }) =>
      throw _privateConstructorUsedError;

  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? sales,
    TResult Function()? vendor,
    TResult Function()? client,
    TResult Function()? delivery,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AppsNamesCopyWith<$Res> {
  factory $AppsNamesCopyWith(AppsNames value, $Res Function(AppsNames) then) = _$AppsNamesCopyWithImpl<$Res, AppsNames>;
}

/// @nodoc
class _$AppsNamesCopyWithImpl<$Res, $Val extends AppsNames> implements $AppsNamesCopyWith<$Res> {
  _$AppsNamesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$AppsNamesSalesCopyWith<$Res> {
  factory _$$AppsNamesSalesCopyWith(_$AppsNamesSales value, $Res Function(_$AppsNamesSales) then) = __$$AppsNamesSalesCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AppsNamesSalesCopyWithImpl<$Res> extends _$AppsNamesCopyWithImpl<$Res, _$AppsNamesSales> implements _$$AppsNamesSalesCopyWith<$Res> {
  __$$AppsNamesSalesCopyWithImpl(_$AppsNamesSales _value, $Res Function(_$AppsNamesSales) _then) : super(_value, _then);
}

/// @nodoc

class _$AppsNamesSales implements AppsNamesSales {
  const _$AppsNamesSales();

  @override
  String toString() {
    return 'sales';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other.runtimeType == runtimeType && other is _$AppsNamesSales);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  TResult when<TResult extends Object?>({
    required TResult Function() sales,
    required TResult Function() vendor,
    required TResult Function() client,
    required TResult Function() delivery,
  }) {
    return sales();
  }

  @override
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? sales,
    TResult? Function()? vendor,
    TResult? Function()? client,
    TResult? Function()? delivery,
  }) {
    return sales?.call();
  }

  @override
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? sales,
    TResult Function()? vendor,
    TResult Function()? client,
    TResult Function()? delivery,
    required TResult orElse(),
  }) {
    if (sales != null) {
      return sales();
    }
    return orElse();
  }
}

abstract class AppsNamesSales implements AppsNames {
  const factory AppsNamesSales() = _$AppsNamesSales;
}

/// @nodoc
abstract class _$$AppsNamesVendorCopyWith<$Res> {
  factory _$$AppsNamesVendorCopyWith(_$AppsNamesVendor value, $Res Function(_$AppsNamesVendor) then) = __$$AppsNamesVendorCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AppsNamesVendorCopyWithImpl<$Res> extends _$AppsNamesCopyWithImpl<$Res, _$AppsNamesVendor> implements _$$AppsNamesVendorCopyWith<$Res> {
  __$$AppsNamesVendorCopyWithImpl(_$AppsNamesVendor _value, $Res Function(_$AppsNamesVendor) _then) : super(_value, _then);
}

/// @nodoc

class _$AppsNamesVendor implements AppsNamesVendor {
  const _$AppsNamesVendor();

  @override
  String toString() {
    return 'vendor';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other.runtimeType == runtimeType && other is _$AppsNamesVendor);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  TResult when<TResult extends Object?>({
    required TResult Function() sales,
    required TResult Function() vendor,
    required TResult Function() client,
    required TResult Function() delivery,
  }) {
    return vendor();
  }

  @override
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? sales,
    TResult? Function()? vendor,
    TResult? Function()? client,
    TResult? Function()? delivery,
  }) {
    return vendor?.call();
  }

  @override
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? sales,
    TResult Function()? vendor,
    TResult Function()? client,
    TResult Function()? delivery,
    required TResult orElse(),
  }) {
    if (vendor != null) {
      return vendor();
    }
    return orElse();
  }
}

abstract class AppsNamesVendor implements AppsNames {
  const factory AppsNamesVendor() = _$AppsNamesVendor;
}

/// @nodoc
abstract class _$$AppsNamesClientCopyWith<$Res> {
  factory _$$AppsNamesClientCopyWith(_$AppsNamesClient value, $Res Function(_$AppsNamesClient) then) = __$$AppsNamesClientCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AppsNamesClientCopyWithImpl<$Res> extends _$AppsNamesCopyWithImpl<$Res, _$AppsNamesClient> implements _$$AppsNamesClientCopyWith<$Res> {
  __$$AppsNamesClientCopyWithImpl(_$AppsNamesClient _value, $Res Function(_$AppsNamesClient) _then) : super(_value, _then);
}

/// @nodoc

class _$AppsNamesClient implements AppsNamesClient {
  const _$AppsNamesClient();

  @override
  String toString() {
    return 'client';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other.runtimeType == runtimeType && other is _$AppsNamesClient);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  TResult when<TResult extends Object?>({
    required TResult Function() sales,
    required TResult Function() vendor,
    required TResult Function() client,
    required TResult Function() delivery,
  }) {
    return client();
  }

  @override
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? sales,
    TResult? Function()? vendor,
    TResult? Function()? client,
    TResult? Function()? delivery,
  }) {
    return client?.call();
  }

  @override
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? sales,
    TResult Function()? vendor,
    TResult Function()? client,
    TResult Function()? delivery,
    required TResult orElse(),
  }) {
    if (client != null) {
      return client();
    }
    return orElse();
  }
}

abstract class AppsNamesClient implements AppsNames {
  const factory AppsNamesClient() = _$AppsNamesClient;
}

/// @nodoc
abstract class _$$AppsNamesDeliveryCopyWith<$Res> {
  factory _$$AppsNamesDeliveryCopyWith(_$AppsNamesDelivery value, $Res Function(_$AppsNamesDelivery) then) = __$$AppsNamesDeliveryCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AppsNamesDeliveryCopyWithImpl<$Res> extends _$AppsNamesCopyWithImpl<$Res, _$AppsNamesDelivery> implements _$$AppsNamesDeliveryCopyWith<$Res> {
  __$$AppsNamesDeliveryCopyWithImpl(_$AppsNamesDelivery _value, $Res Function(_$AppsNamesDelivery) _then) : super(_value, _then);
}

/// @nodoc

class _$AppsNamesDelivery implements AppsNamesDelivery {
  const _$AppsNamesDelivery();

  @override
  String toString() {
    return 'delivery';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other.runtimeType == runtimeType && other is _$AppsNamesDelivery);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  TResult when<TResult extends Object?>({
    required TResult Function() sales,
    required TResult Function() vendor,
    required TResult Function() client,
    required TResult Function() delivery,
  }) {
    return delivery();
  }

  @override
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? sales,
    TResult? Function()? vendor,
    TResult? Function()? client,
    TResult? Function()? delivery,
  }) {
    return delivery?.call();
  }

  @override
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? sales,
    TResult Function()? vendor,
    TResult Function()? client,
    TResult Function()? delivery,
    required TResult orElse(),
  }) {
    if (delivery != null) {
      return delivery();
    }
    return orElse();
  }
}

abstract class AppsNamesDelivery implements AppsNames {
  const factory AppsNamesDelivery() = _$AppsNamesDelivery;
}
