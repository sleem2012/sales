// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'shipment_type.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$ServiceType {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() shopping,
    required TResult Function() ticketing,
    required TResult Function() service,
    required TResult Function() carrying,
    required TResult Function() display,
    required TResult Function() client_base,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? shopping,
    TResult? Function()? ticketing,
    TResult? Function()? service,
    TResult? Function()? carrying,
    TResult? Function()? display,
    TResult? Function()? client_base,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? shopping,
    TResult Function()? ticketing,
    TResult Function()? service,
    TResult Function()? carrying,
    TResult Function()? display,
    TResult Function()? client_base,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ServiceTypeShopping value) shopping,
    required TResult Function(ServiceTypeTicketing value) ticketing,
    required TResult Function(ServiceTypeService value) service,
    required TResult Function(ServiceTypeCarrying value) carrying,
    required TResult Function(ServiceTypeDisplay value) display,
    required TResult Function(ServiceTypeClientBase value) client_base,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ServiceTypeShopping value)? shopping,
    TResult? Function(ServiceTypeTicketing value)? ticketing,
    TResult? Function(ServiceTypeService value)? service,
    TResult? Function(ServiceTypeCarrying value)? carrying,
    TResult? Function(ServiceTypeDisplay value)? display,
    TResult? Function(ServiceTypeClientBase value)? client_base,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ServiceTypeShopping value)? shopping,
    TResult Function(ServiceTypeTicketing value)? ticketing,
    TResult Function(ServiceTypeService value)? service,
    TResult Function(ServiceTypeCarrying value)? carrying,
    TResult Function(ServiceTypeDisplay value)? display,
    TResult Function(ServiceTypeClientBase value)? client_base,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ServiceTypeCopyWith<$Res> {
  factory $ServiceTypeCopyWith(
          ServiceType value, $Res Function(ServiceType) then) =
      _$ServiceTypeCopyWithImpl<$Res, ServiceType>;
}

/// @nodoc
class _$ServiceTypeCopyWithImpl<$Res, $Val extends ServiceType>
    implements $ServiceTypeCopyWith<$Res> {
  _$ServiceTypeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ServiceTypeShoppingCopyWith<$Res> {
  factory _$$ServiceTypeShoppingCopyWith(_$ServiceTypeShopping value,
          $Res Function(_$ServiceTypeShopping) then) =
      __$$ServiceTypeShoppingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ServiceTypeShoppingCopyWithImpl<$Res>
    extends _$ServiceTypeCopyWithImpl<$Res, _$ServiceTypeShopping>
    implements _$$ServiceTypeShoppingCopyWith<$Res> {
  __$$ServiceTypeShoppingCopyWithImpl(
      _$ServiceTypeShopping _value, $Res Function(_$ServiceTypeShopping) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ServiceTypeShopping implements ServiceTypeShopping {
  const _$ServiceTypeShopping();

  @override
  String toString() {
    return 'ServiceType.shopping()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ServiceTypeShopping);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() shopping,
    required TResult Function() ticketing,
    required TResult Function() service,
    required TResult Function() carrying,
    required TResult Function() display,
    required TResult Function() client_base,
  }) {
    return shopping();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? shopping,
    TResult? Function()? ticketing,
    TResult? Function()? service,
    TResult? Function()? carrying,
    TResult? Function()? display,
    TResult? Function()? client_base,
  }) {
    return shopping?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? shopping,
    TResult Function()? ticketing,
    TResult Function()? service,
    TResult Function()? carrying,
    TResult Function()? display,
    TResult Function()? client_base,
    required TResult orElse(),
  }) {
    if (shopping != null) {
      return shopping();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ServiceTypeShopping value) shopping,
    required TResult Function(ServiceTypeTicketing value) ticketing,
    required TResult Function(ServiceTypeService value) service,
    required TResult Function(ServiceTypeCarrying value) carrying,
    required TResult Function(ServiceTypeDisplay value) display,
    required TResult Function(ServiceTypeClientBase value) client_base,
  }) {
    return shopping(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ServiceTypeShopping value)? shopping,
    TResult? Function(ServiceTypeTicketing value)? ticketing,
    TResult? Function(ServiceTypeService value)? service,
    TResult? Function(ServiceTypeCarrying value)? carrying,
    TResult? Function(ServiceTypeDisplay value)? display,
    TResult? Function(ServiceTypeClientBase value)? client_base,
  }) {
    return shopping?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ServiceTypeShopping value)? shopping,
    TResult Function(ServiceTypeTicketing value)? ticketing,
    TResult Function(ServiceTypeService value)? service,
    TResult Function(ServiceTypeCarrying value)? carrying,
    TResult Function(ServiceTypeDisplay value)? display,
    TResult Function(ServiceTypeClientBase value)? client_base,
    required TResult orElse(),
  }) {
    if (shopping != null) {
      return shopping(this);
    }
    return orElse();
  }
}

abstract class ServiceTypeShopping implements ServiceType {
  const factory ServiceTypeShopping() = _$ServiceTypeShopping;
}

/// @nodoc
abstract class _$$ServiceTypeTicketingCopyWith<$Res> {
  factory _$$ServiceTypeTicketingCopyWith(_$ServiceTypeTicketing value,
          $Res Function(_$ServiceTypeTicketing) then) =
      __$$ServiceTypeTicketingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ServiceTypeTicketingCopyWithImpl<$Res>
    extends _$ServiceTypeCopyWithImpl<$Res, _$ServiceTypeTicketing>
    implements _$$ServiceTypeTicketingCopyWith<$Res> {
  __$$ServiceTypeTicketingCopyWithImpl(_$ServiceTypeTicketing _value,
      $Res Function(_$ServiceTypeTicketing) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ServiceTypeTicketing implements ServiceTypeTicketing {
  const _$ServiceTypeTicketing();

  @override
  String toString() {
    return 'ServiceType.ticketing()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ServiceTypeTicketing);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() shopping,
    required TResult Function() ticketing,
    required TResult Function() service,
    required TResult Function() carrying,
    required TResult Function() display,
    required TResult Function() client_base,
  }) {
    return ticketing();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? shopping,
    TResult? Function()? ticketing,
    TResult? Function()? service,
    TResult? Function()? carrying,
    TResult? Function()? display,
    TResult? Function()? client_base,
  }) {
    return ticketing?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? shopping,
    TResult Function()? ticketing,
    TResult Function()? service,
    TResult Function()? carrying,
    TResult Function()? display,
    TResult Function()? client_base,
    required TResult orElse(),
  }) {
    if (ticketing != null) {
      return ticketing();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ServiceTypeShopping value) shopping,
    required TResult Function(ServiceTypeTicketing value) ticketing,
    required TResult Function(ServiceTypeService value) service,
    required TResult Function(ServiceTypeCarrying value) carrying,
    required TResult Function(ServiceTypeDisplay value) display,
    required TResult Function(ServiceTypeClientBase value) client_base,
  }) {
    return ticketing(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ServiceTypeShopping value)? shopping,
    TResult? Function(ServiceTypeTicketing value)? ticketing,
    TResult? Function(ServiceTypeService value)? service,
    TResult? Function(ServiceTypeCarrying value)? carrying,
    TResult? Function(ServiceTypeDisplay value)? display,
    TResult? Function(ServiceTypeClientBase value)? client_base,
  }) {
    return ticketing?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ServiceTypeShopping value)? shopping,
    TResult Function(ServiceTypeTicketing value)? ticketing,
    TResult Function(ServiceTypeService value)? service,
    TResult Function(ServiceTypeCarrying value)? carrying,
    TResult Function(ServiceTypeDisplay value)? display,
    TResult Function(ServiceTypeClientBase value)? client_base,
    required TResult orElse(),
  }) {
    if (ticketing != null) {
      return ticketing(this);
    }
    return orElse();
  }
}

abstract class ServiceTypeTicketing implements ServiceType {
  const factory ServiceTypeTicketing() = _$ServiceTypeTicketing;
}

/// @nodoc
abstract class _$$ServiceTypeServiceCopyWith<$Res> {
  factory _$$ServiceTypeServiceCopyWith(_$ServiceTypeService value,
          $Res Function(_$ServiceTypeService) then) =
      __$$ServiceTypeServiceCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ServiceTypeServiceCopyWithImpl<$Res>
    extends _$ServiceTypeCopyWithImpl<$Res, _$ServiceTypeService>
    implements _$$ServiceTypeServiceCopyWith<$Res> {
  __$$ServiceTypeServiceCopyWithImpl(
      _$ServiceTypeService _value, $Res Function(_$ServiceTypeService) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ServiceTypeService implements ServiceTypeService {
  const _$ServiceTypeService();

  @override
  String toString() {
    return 'ServiceType.service()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ServiceTypeService);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() shopping,
    required TResult Function() ticketing,
    required TResult Function() service,
    required TResult Function() carrying,
    required TResult Function() display,
    required TResult Function() client_base,
  }) {
    return service();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? shopping,
    TResult? Function()? ticketing,
    TResult? Function()? service,
    TResult? Function()? carrying,
    TResult? Function()? display,
    TResult? Function()? client_base,
  }) {
    return service?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? shopping,
    TResult Function()? ticketing,
    TResult Function()? service,
    TResult Function()? carrying,
    TResult Function()? display,
    TResult Function()? client_base,
    required TResult orElse(),
  }) {
    if (service != null) {
      return service();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ServiceTypeShopping value) shopping,
    required TResult Function(ServiceTypeTicketing value) ticketing,
    required TResult Function(ServiceTypeService value) service,
    required TResult Function(ServiceTypeCarrying value) carrying,
    required TResult Function(ServiceTypeDisplay value) display,
    required TResult Function(ServiceTypeClientBase value) client_base,
  }) {
    return service(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ServiceTypeShopping value)? shopping,
    TResult? Function(ServiceTypeTicketing value)? ticketing,
    TResult? Function(ServiceTypeService value)? service,
    TResult? Function(ServiceTypeCarrying value)? carrying,
    TResult? Function(ServiceTypeDisplay value)? display,
    TResult? Function(ServiceTypeClientBase value)? client_base,
  }) {
    return service?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ServiceTypeShopping value)? shopping,
    TResult Function(ServiceTypeTicketing value)? ticketing,
    TResult Function(ServiceTypeService value)? service,
    TResult Function(ServiceTypeCarrying value)? carrying,
    TResult Function(ServiceTypeDisplay value)? display,
    TResult Function(ServiceTypeClientBase value)? client_base,
    required TResult orElse(),
  }) {
    if (service != null) {
      return service(this);
    }
    return orElse();
  }
}

abstract class ServiceTypeService implements ServiceType {
  const factory ServiceTypeService() = _$ServiceTypeService;
}

/// @nodoc
abstract class _$$ServiceTypeCarryingCopyWith<$Res> {
  factory _$$ServiceTypeCarryingCopyWith(_$ServiceTypeCarrying value,
          $Res Function(_$ServiceTypeCarrying) then) =
      __$$ServiceTypeCarryingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ServiceTypeCarryingCopyWithImpl<$Res>
    extends _$ServiceTypeCopyWithImpl<$Res, _$ServiceTypeCarrying>
    implements _$$ServiceTypeCarryingCopyWith<$Res> {
  __$$ServiceTypeCarryingCopyWithImpl(
      _$ServiceTypeCarrying _value, $Res Function(_$ServiceTypeCarrying) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ServiceTypeCarrying implements ServiceTypeCarrying {
  const _$ServiceTypeCarrying();

  @override
  String toString() {
    return 'ServiceType.carrying()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ServiceTypeCarrying);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() shopping,
    required TResult Function() ticketing,
    required TResult Function() service,
    required TResult Function() carrying,
    required TResult Function() display,
    required TResult Function() client_base,
  }) {
    return carrying();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? shopping,
    TResult? Function()? ticketing,
    TResult? Function()? service,
    TResult? Function()? carrying,
    TResult? Function()? display,
    TResult? Function()? client_base,
  }) {
    return carrying?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? shopping,
    TResult Function()? ticketing,
    TResult Function()? service,
    TResult Function()? carrying,
    TResult Function()? display,
    TResult Function()? client_base,
    required TResult orElse(),
  }) {
    if (carrying != null) {
      return carrying();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ServiceTypeShopping value) shopping,
    required TResult Function(ServiceTypeTicketing value) ticketing,
    required TResult Function(ServiceTypeService value) service,
    required TResult Function(ServiceTypeCarrying value) carrying,
    required TResult Function(ServiceTypeDisplay value) display,
    required TResult Function(ServiceTypeClientBase value) client_base,
  }) {
    return carrying(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ServiceTypeShopping value)? shopping,
    TResult? Function(ServiceTypeTicketing value)? ticketing,
    TResult? Function(ServiceTypeService value)? service,
    TResult? Function(ServiceTypeCarrying value)? carrying,
    TResult? Function(ServiceTypeDisplay value)? display,
    TResult? Function(ServiceTypeClientBase value)? client_base,
  }) {
    return carrying?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ServiceTypeShopping value)? shopping,
    TResult Function(ServiceTypeTicketing value)? ticketing,
    TResult Function(ServiceTypeService value)? service,
    TResult Function(ServiceTypeCarrying value)? carrying,
    TResult Function(ServiceTypeDisplay value)? display,
    TResult Function(ServiceTypeClientBase value)? client_base,
    required TResult orElse(),
  }) {
    if (carrying != null) {
      return carrying(this);
    }
    return orElse();
  }
}

abstract class ServiceTypeCarrying implements ServiceType {
  const factory ServiceTypeCarrying() = _$ServiceTypeCarrying;
}

/// @nodoc
abstract class _$$ServiceTypeDisplayCopyWith<$Res> {
  factory _$$ServiceTypeDisplayCopyWith(_$ServiceTypeDisplay value,
          $Res Function(_$ServiceTypeDisplay) then) =
      __$$ServiceTypeDisplayCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ServiceTypeDisplayCopyWithImpl<$Res>
    extends _$ServiceTypeCopyWithImpl<$Res, _$ServiceTypeDisplay>
    implements _$$ServiceTypeDisplayCopyWith<$Res> {
  __$$ServiceTypeDisplayCopyWithImpl(
      _$ServiceTypeDisplay _value, $Res Function(_$ServiceTypeDisplay) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ServiceTypeDisplay implements ServiceTypeDisplay {
  const _$ServiceTypeDisplay();

  @override
  String toString() {
    return 'ServiceType.display()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ServiceTypeDisplay);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() shopping,
    required TResult Function() ticketing,
    required TResult Function() service,
    required TResult Function() carrying,
    required TResult Function() display,
    required TResult Function() client_base,
  }) {
    return display();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? shopping,
    TResult? Function()? ticketing,
    TResult? Function()? service,
    TResult? Function()? carrying,
    TResult? Function()? display,
    TResult? Function()? client_base,
  }) {
    return display?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? shopping,
    TResult Function()? ticketing,
    TResult Function()? service,
    TResult Function()? carrying,
    TResult Function()? display,
    TResult Function()? client_base,
    required TResult orElse(),
  }) {
    if (display != null) {
      return display();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ServiceTypeShopping value) shopping,
    required TResult Function(ServiceTypeTicketing value) ticketing,
    required TResult Function(ServiceTypeService value) service,
    required TResult Function(ServiceTypeCarrying value) carrying,
    required TResult Function(ServiceTypeDisplay value) display,
    required TResult Function(ServiceTypeClientBase value) client_base,
  }) {
    return display(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ServiceTypeShopping value)? shopping,
    TResult? Function(ServiceTypeTicketing value)? ticketing,
    TResult? Function(ServiceTypeService value)? service,
    TResult? Function(ServiceTypeCarrying value)? carrying,
    TResult? Function(ServiceTypeDisplay value)? display,
    TResult? Function(ServiceTypeClientBase value)? client_base,
  }) {
    return display?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ServiceTypeShopping value)? shopping,
    TResult Function(ServiceTypeTicketing value)? ticketing,
    TResult Function(ServiceTypeService value)? service,
    TResult Function(ServiceTypeCarrying value)? carrying,
    TResult Function(ServiceTypeDisplay value)? display,
    TResult Function(ServiceTypeClientBase value)? client_base,
    required TResult orElse(),
  }) {
    if (display != null) {
      return display(this);
    }
    return orElse();
  }
}

abstract class ServiceTypeDisplay implements ServiceType {
  const factory ServiceTypeDisplay() = _$ServiceTypeDisplay;
}

/// @nodoc
abstract class _$$ServiceTypeClientBaseCopyWith<$Res> {
  factory _$$ServiceTypeClientBaseCopyWith(_$ServiceTypeClientBase value,
          $Res Function(_$ServiceTypeClientBase) then) =
      __$$ServiceTypeClientBaseCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ServiceTypeClientBaseCopyWithImpl<$Res>
    extends _$ServiceTypeCopyWithImpl<$Res, _$ServiceTypeClientBase>
    implements _$$ServiceTypeClientBaseCopyWith<$Res> {
  __$$ServiceTypeClientBaseCopyWithImpl(_$ServiceTypeClientBase _value,
      $Res Function(_$ServiceTypeClientBase) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ServiceTypeClientBase implements ServiceTypeClientBase {
  const _$ServiceTypeClientBase();

  @override
  String toString() {
    return 'ServiceType.client_base()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ServiceTypeClientBase);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() shopping,
    required TResult Function() ticketing,
    required TResult Function() service,
    required TResult Function() carrying,
    required TResult Function() display,
    required TResult Function() client_base,
  }) {
    return client_base();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? shopping,
    TResult? Function()? ticketing,
    TResult? Function()? service,
    TResult? Function()? carrying,
    TResult? Function()? display,
    TResult? Function()? client_base,
  }) {
    return client_base?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? shopping,
    TResult Function()? ticketing,
    TResult Function()? service,
    TResult Function()? carrying,
    TResult Function()? display,
    TResult Function()? client_base,
    required TResult orElse(),
  }) {
    if (client_base != null) {
      return client_base();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ServiceTypeShopping value) shopping,
    required TResult Function(ServiceTypeTicketing value) ticketing,
    required TResult Function(ServiceTypeService value) service,
    required TResult Function(ServiceTypeCarrying value) carrying,
    required TResult Function(ServiceTypeDisplay value) display,
    required TResult Function(ServiceTypeClientBase value) client_base,
  }) {
    return client_base(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ServiceTypeShopping value)? shopping,
    TResult? Function(ServiceTypeTicketing value)? ticketing,
    TResult? Function(ServiceTypeService value)? service,
    TResult? Function(ServiceTypeCarrying value)? carrying,
    TResult? Function(ServiceTypeDisplay value)? display,
    TResult? Function(ServiceTypeClientBase value)? client_base,
  }) {
    return client_base?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ServiceTypeShopping value)? shopping,
    TResult Function(ServiceTypeTicketing value)? ticketing,
    TResult Function(ServiceTypeService value)? service,
    TResult Function(ServiceTypeCarrying value)? carrying,
    TResult Function(ServiceTypeDisplay value)? display,
    TResult Function(ServiceTypeClientBase value)? client_base,
    required TResult orElse(),
  }) {
    if (client_base != null) {
      return client_base(this);
    }
    return orElse();
  }
}

abstract class ServiceTypeClientBase implements ServiceType {
  const factory ServiceTypeClientBase() = _$ServiceTypeClientBase;
}
